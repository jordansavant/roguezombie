# Diffing delta fields is very awkward
# It requires manually knowing the fields

# Also how do we structure the packet in a way that it can be unserialized?
# This has to be done for a LOT of object types
# C++ cannot use reflection to diff it

Source engine uses C++ macros to replace all member variables that need to
be flagged for updates with a special type that will trigger a flag
on the parent object to signal it for delta compression

Source engine uses Send Tables on the server models
to identify how member variables can
be squeezed down into bytes for transfer
This can be used to squeeze an int down to four bits instead of 32 if
it never exceeds 15 etc.

Source engine uses Receive Tables on the client models

These tables can have indices, so the packed bytestream can be
index=>value packed and the index can directly look at the field
and assign it the value.

// Thoughts
// Perhaps if the array of indices on the client model pointed
// to lambda functions that set the members, this could
// be generated by macros, and the indices could fire the lambda
// passing the value

Source engine uses Potential Visibility Set to identify potential
rooms that the user can see to send data
Source engine also sends a subset of other entities based on vicinity


Quake sends packets at max 1400 bytes to avoid packet fragmentation
on routers
Quake uses Preprocessors as well to build an array of fields... hmmm


