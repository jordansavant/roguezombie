Possible titles:
- Rogue Zombie
- ZRL


--------------------
RZ Bugs

Body's are LevelRunnable but if we delete one it will screw up references in the parent tile
- Tiles point to structures, doors or characters on them, deleting them needs to remove references
- Or protect against deleting them somehow*

Hunters firing after dead
- Ive seen flare visualization after they are killed
- On closer look it might be some left over from a grenade flair
- As if the grenade lighting is moving slightly past the Update ratio and rolling over?

Fat gap under Loot Interaction popup
- Only looks weird under singular loot option (like looting a dead guy)

Characters retain pointers to attack targets
- If the attack target disappears between decision to attack and attack sequence we will have a memory violation
- Change the pointer to a Tile* or an X and Y which will fetch a tile and therefore a character
- If the tile has no body (character) then we can skip attack
- Same for all server side elements, they should point to tiles, not to characters (or structures) etc

Tiles and lights are still performance hogs
- Currently lights only update if they are in the player range
- But the list of tiles is still updating
- Consider implementing the range based updates mentioned in the features below

CURRENTLY
- QuadTree has been implemented but needs to be moved back into a Template so I can fill lists of the subclass data type
- I need to settle on a QuadSize limit
	- rooms are currently max 16x16, this means I need to be able to stand on one side and see changes on the other
	- That would indicate being able to get tiles up to 32 away
	- That would give us a maxSize of 1024, which is 1/4 of the current tile set
	- We could further optimize by flagging tiles as unreachable in the mapgenerator, then never adding them to the quadtree
- Also I need to implement the rangedUpdate method for Tile and Light
- Also I need to eliminate the normal update methods for Tile and Light
	- This should reduce processing overhead instead of iterating entire list each cycle
	- This quadtree reduction is useless if I am still running normal updates

--------------------
RZ Features

Need much better AI for Hunters
- They should make chase - If they encounter the player and the player breaks LoS, they should go to the player's last seen location

Items should have stat effects and perhaps magical (lambda) effects
- Maybe rarity (green/blue/purple/orange)?
- Better stat details in the window

Procedural levels
- https://www.rockpapershotgun.com/2015/07/28/how-do-roguelikes-generate-levels/
- http://www.gridsagegames.com/blog/2014/06/procedural-map-generation/
- http://donjon.bin.sh/d20/dungeon/
- http://donjon.bin.sh/code/dungeon/
- http://donjon.bin.sh/code/dungeon/dungeon.pl
- TO DO:
	- Floodfill entrance landing pads
	- Lights, enemies, structures, items
	- Given hallways we must figure out how to move over and beyond dead bodies

Implement playerRangeUpdate
- Organize tiles and lights into quadTree structures
- On level update only run PlayerRangeUpdate for tiles or lights within X range of players
- Could do this also with characters and structures
- This should reduce the update overhead of a large map, only loading and running updates on elements within certain ranges
- Modernize QuadTree
	- Remove old crap code
- Put lights and tiles into quadtrees
- During update cycle get quads where players are located and update them using rangedUpdate
- Probably going to have to abandon LevelRunner now, too much divergent processing

Better stair tiles

Map

Ability to move with WASD, even in combat
- Display combat movements remaining in HUD

Ability to Trash items in the inventory

Flavor console line

Upgrade SFML to v2.4


--------------------
RZ Potential issues

Laggy while debugging
- Look at possibility of local semaphor packet sending?


--------------------
RZ Scope

I've decided to go the route of level gen for a single tower, took a few days to get something working but its a good foundation

You play has human characters in the apocalypse
You must ascend a tower to the helicopter on top
The tower is dangerous, robots, hunters, zombies, its ground zero perhaps
Level one is ground floor prefab, it is the only place that players can join for partying
Level two until top are procedurally generated with themes such as: medical, robotics, offices, labs
Level top is a prefab of a boss fight and the escape
Levels can have a prefab thematic elements and rooms to carry plotline and ensure level exploration


--------------------
Threaded Sockets

The client has a TcpSocket
The server has a TcpListener

Both are parented by Socket

Client uses:
	socket.connect
	socket.setBlocking
	socket.receive
	socket.send

Server uses:
	listenerSocket.setBlocking
	listenerSocket.listen
	listenerSocket.close
	listenerSocket.accept
	client->socket.send
	client->socket.receive
	client->socket.disconnect

	
Rough process
1. Server starts listening
2. Client connects
3. Server accepts
4. Server close
5. Server sends
6. Client receives
7. Client sends
8. Server receives
9. Client disconnect
10. Server listens


A server has an IP address and listens to a specific port
A client connects to that IP address and port
When the socket is accepted data is sent and received


In local hosting the server is running in a thread separated from the client.
When the server needs to send data it could MUTEX copy the packet into a queue of packets to be sent
A bool is set that packets are pending
The client socket would poll the bool until it was set, it would then MUTEX the queue and pop off a packet

The server has a list of client sockets and could copy packets to their specific instance queues when packets are sent (in this case, one client)

To implement we would need to wrap the TcpSocket and TcpListener and sf::Socket classes with bit versions
Then we would need two bit versions, one that was the SFML network implementation and two that was the threaded queue version

Phase 1:
- Plan out all ^^used methods for both SFML networked and BIT threaded versions
- Create BIT wrappers that used SFML networking
- Create BIT wrappers that used threads


