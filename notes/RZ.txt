Possible titles:
- Rogue Zombie
- ZRL


--------------------
RZ Bugs

Body's are LevelRunnable but if we delete one it will screw up references in the parent tile
- Tiles point to structures, doors or characters on them, deleting them needs to remove references
- Or protect against deleting them somehow*

Hunters firing after dead
- Ive seen flare visualization after they are killed
- On closer look it might be some left over from a grenade flair
- As if the grenade lighting is moving slightly past the Update ratio and rolling over?

Fat gap under Loot Interaction popup
- Only looks weird under singular loot option (like looting a dead guy)

Characters retain pointers to attack targets
- If the attack target disappears between decision to attack and attack sequence we will have a memory violation
- Change the pointer to a Tile* or an X and Y which will fetch a tile and therefore a character
- If the tile has no body (character) then we can skip attack
- Same for all server side elements, they should point to tiles, not to characters (or structures) etc


--------------------
RZ Features

Need much better AI for Hunters
- They should make chase - If they encounter the player and the player breaks LoS, they should go to the player's last seen location

Items should have stat effects and perhaps magical (lambda) effects
- Maybe rarity (green/blue/purple/orange)?
- Better stat details in the window

Procedural levels
- Traps, Chasms, Machines
- https://www.rockpapershotgun.com/2015/07/28/how-do-roguelikes-generate-levels/
- http://www.gridsagegames.com/blog/2014/06/procedural-map-generation/
- http://donjon.bin.sh/d20/dungeon/
- http://donjon.bin.sh/code/dungeon/
- http://donjon.bin.sh/code/dungeon/dungeon.pl

Level Gen TO DO:
- Have sills pick based on Map odd/even instead of every other so that they can universally align
- Clean up routines need to fix doors that had tunnels collapsed
- Doors tunelling outward can make tunnels that corner to corner with other tunnels (can they be shadowcasted through?)

- When sills are selected they should check that:
	- their perpendicular wall spot is not blocked (should never be)
	- the spot beyond that in the same direction is not blocked (dont see why it would be)
	- the spot beyond the door is not on the outside corner of another room

- Corridors
	- Essentially scans all locations and recursively digs tunnels across entire map
	- Direction splits (or turns if only one) are returned as a collection from a direction routine that uses random chance to determine number of turns
		- Labyrinthian style would randomly change direction
		- Errant style would stay straight 50% of the time
		- Straight style would stay straight 90% of the time
	- For each direction from current position we try to open the tunnel
		- Get next position and additional position beyond
		- If the additional position beyond is a room permiter we stop
		- If the additional position beyond is a coridor we stop
		- Otherwise we emplace the tunnel
	- Our only stop condition is running into a room or another corridor


Ability to Trash items in the inventory

Flavor console line

Upgrade SFML to v2.4


--------------------
RZ Potential issues

Doorways can be blocked if bodies die in front of them

Laggy while debugging
- Look at possibility of local semaphor packet sending?


--------------------
RZ Scoping issues

If I use the city generator and also want level generation to work for buildings, homes, subways etc we have a TON of level generation to build
Say we do get level generation built out, how do you make this fun? Whats the point if its not fun?
Hundreds of items (or smartly generated ones) will need to be created
And whats to drive the player to explore? And how do you balance something so expansive?
In Brogue its about reaching level 26, so the entire game is balanced for 26 levels of generation
I have a multiplayer hook and that is honestly what is giving it its edge
Perhaps I should step away from the scale of the city generator and focus on generating solid building / facilities with storage
Also nothing is holding me down to playing as a zombie, I could do the typical survival as a human route

If players are expecting a brogueish quality then there is a ton of balancing, machining and nifty generation to create
Dealing with the network is very cumberson compared to what these other guys build, but at the same time its my leg up
I have a decent mission system, narrative system and loot system that perhaps could be automatically generated

We could change the scope of the game back to a tower ascent/descent with a series of procedurally generated facility floors
That would scope our level generation to a single building (with perhaps basement, caverns, and subway escape
It could also allow us to procedurally include scripted plotline, characters and events


--------------------
Threaded Sockets

The client has a TcpSocket
The server has a TcpListener

Both are parented by Socket

Client uses:
	socket.connect
	socket.setBlocking
	socket.receive
	socket.send

Server uses:
	listenerSocket.setBlocking
	listenerSocket.listen
	listenerSocket.close
	listenerSocket.accept
	client->socket.send
	client->socket.receive
	client->socket.disconnect

	
Rough process
1. Server starts listening
2. Client connects
3. Server accepts
4. Server close
5. Server sends
6. Client receives
7. Client sends
8. Server receives
9. Client disconnect
10. Server listens


A server has an IP address and listens to a specific port
A client connects to that IP address and port
When the socket is accepted data is sent and received


In local hosting the server is running in a thread separated from the client.
When the server needs to send data it could MUTEX copy the packet into a queue of packets to be sent
A bool is set that packets are pending
The client socket would poll the bool until it was set, it would then MUTEX the queue and pop off a packet

The server has a list of client sockets and could copy packets to their specific instance queues when packets are sent (in this case, one client)

To implement we would need to wrap the TcpSocket and TcpListener and sf::Socket classes with bit versions
Then we would need two bit versions, one that was the SFML network implementation and two that was the threaded queue version

Phase 1:
- Plan out all ^^used methods for both SFML networked and BIT threaded versions
- Create BIT wrappers that used SFML networking
- Create BIT wrappers that used threads


